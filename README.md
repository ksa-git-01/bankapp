# Проектная работа 9 спринта

## Spring Boot приложение BankApp

### Технологии

```
Java 21
Spring Boot 3.5.4
PostgreSQL 16.9
Maven
Testcontainers
Docker & Docker Compose
Keycloak
Consul
```

### Требования к окружению

```
Docker Desktop
JDK 21
Клонировать репозиторий: https://github.com/ksa-git-01/bankapp.git
```

### Запуск тестов

Из корня проекта:

```
./mvnw clean test
```

Первый запуск может быть долгим, т.к. будут скачаны необходимые образы и зависимости

### Сборка и запуск

Из корня проекта:

```
docker-compose up
```

Используются порты ОС хоста:
8080..8086 - Сервисы
15433 - PostgreSQL keycloak
15432 - PostgreSQL Accounts
18080 - Веб-интерфейс keycloak
8500 - Consul 

Первый запуск может быть долгим, т.к. будут скачаны необходимые образы и зависимости

### Ресурсы проекта

```
Веб-страницы:
Главная страница: http://localhost:8080
Страница регистрации пользователя: http://localhost:8080/signup

Публичная информация о реалме keycloak:
http://localhost:18080/realms/bankapp
```

### Схема взаимодействия
```
Все сервисы при старте регистрируются в Consul.
Все сервисы общаются между собой по HTTP через API-Gateway (spring-cloud-starter-gateway-server-webflux) 
используя Service Discovery. Для этого в каждом сервисе создан бин RestTemplate с аннотацией @LoadBalanced
В свойствах каждого проекта прописан базовый путь до Gateway. Далее в каждом клиенте прописаны пути до ручек 
нужных сервисов с префиксом в виде имени сервиса (Gateway по префиксу роутит на нужный сервис также с использованием  
Service Discovery (uri вида lb://....))
```

### FLOW аутентификации и авторизации пользователя
```
Согласно заданию логины и пароли пользователей лежат в БД сервиса Accounts. 
Accounts также является сервисом аутентификации пользователя.
Для авторизации пользователей выбрана STATELESS политика сессий. 
Вместо использования веб-сессий, сервис Accounts генерирует JWT токен пользователя и подписывает его по алгоритму RS256.
RS256 это асимметричный алгоритм подписи который использует приватный ключ. 
Приватный ключ лежит в файле:
accounts/src/main/resources/certs/private.pem
Файл помещен в репозиторий только для упрощения локального запуска. В реальном проекте он бы находился в Vault хранилище.
Для валидации токена используется публичный ключ.
Публичный ключ скопирован в каждый сервис в /src/main/resources/certs/public.pem

FrontUI при попытке логина обращается к Accounts через RemoteAuthenticationProvider на эндпоинт api/auth,
передавая логин и пароль из браузера.
Account проверяет пару логин/пароль и генерирует JWT токен с инф об id пользователя, логином и ролью.
FrontUI помещает токен в http-only cookie "JWT-TOKEN" с помощью CustomAuthenticationSuccessHandler и отдает браузеру.
Далее если из браузера приходит cookie "JWT-TOKEN", токен валидируется публичным ключем. 
Если токен подделан, то выполняется редирект на страницу логина.
Далее при обращении FrontUI в любой другой сервис происходит добавление пользовательского токена в header "X-User-JWT".
Каждый сервис получая запрос валидирует токен из header'а и если все ок, помещает информацию из токена в атрибут userId 
объекта HttpServletRequest и разрешает доступ к эндпоинтам.
Далее в каждом сервисе где это необходимо, из HttpServletRequest извлекается userId из токена и сравнивается с userId, 
который пришел в параметрах http запроса. Таким образом получить доступ к данным пользователь может только при 
наличии валидного токена и только в случае если он делает запрос за "своими" данными.
Пример такой проверки в контроллере:
        Long authenticatedUserId = (Long) httpRequest.getAttribute("userId");

        if (authenticatedUserId == null || !request.fromUserId().equals(authenticatedUserId)) {
            return ResponseEntity.status(403).body(
                    new TransferResponse(false, "Access denied", null, null)
            );
        }
```

### FLOW межсервисной авторизации по OAuth2
```
Параллельно с пользовательской авторизацией в приложении реализована межсервисная авторизация по OAuth2 через Keycloak.
Тут используется стандартный механизм с передачей токена в заголовке Authorization: Bearer ....
Для межсервисной авторизации переиспользуется механизм, который создавался в заданиях прошлого модуля, но с доработкой:
теперь каждый клиент имеет роли доступа к тем или иным сервисам и в каждом сервисе добавлена проверка роли в веб фильтр,
например: .requestMatchers("/api/**").hasRole("cash-access")
Таким образом к сервису cash могут обращаться только сервисы с ролью cash-access и т.д для остальных сервисов.

Для того чтобы поженить между собой два независимых flow авторизации используется метод dualTokenInterceptor в 
конфигурации RestTemplate.
Этот метод выполняет проверку на наличие валидного токена из кейклока. Если него нет, идет в кейклок за новым, 
добавляет его в заголовок Authorization и также добавляет заголовок X-User-JWT куда прописывает токен пользователя.
```

### Примечания по реализации

```
1. В процессе выполнения задания, его текст изменился. Поэтому я успел сделать сервисы Blocker и Transfer, 
но не стал делать сервис получения курсов обмена валют. Т.к. в новой версии задания этого не требовалось, 
а я горел по срокам. Сервис курсов валют реализую в спринте, т.к. вижу что он есть в задании.
2. Валюты обмениваются по курсу 1 к 1. В появлением сервиса курсов валют это будет доработано.
```